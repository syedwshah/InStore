{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport shallowEqual from \"../utils/shallowEqual\";\nvar SCENE_KEY_PREFIX = 'scene_';\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map();\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  nextState.routes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\" + index + \"].key \\\"\" + key + \"\\\" conflicts with \" + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    prevState.routes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      });\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread({}, scene, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  }\n\n  return scenes;\n}","map":{"version":3,"sources":["/Users/shah/Desktop/React_Projects/InStore/node_modules/react-navigation/src/views/ScenesReducer.js"],"names":["invariant","shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","routes","has","add","delete","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one, two) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one, two) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes,\n  nextState,\n  prevState,\n  descriptors\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.routes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n        'another route!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevState.routes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = nextScene => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  invariant(\n    activeScenesCount === 1,\n    'there should always be only one scene active, not %s.',\n    activeScenesCount\n  );\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]},"metadata":{},"sourceType":"module"}